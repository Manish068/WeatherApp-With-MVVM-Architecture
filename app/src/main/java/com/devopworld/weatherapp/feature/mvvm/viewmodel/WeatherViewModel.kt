package com.devopworld.weatherapp.feature.mvvm.viewmodelimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport com.devopworld.weatherapp.Util.DateTimeUtilityimport com.devopworld.weatherapp.Util.NetworkUtilimport com.devopworld.weatherapp.Util.TemperatureUtilityimport com.devopworld.weatherapp.Util.roundOffimport com.devopworld.weatherapp.app.MyAppimport com.devopworld.weatherapp.common.RequestStateimport com.devopworld.weatherapp.feature.mvvm.model.CurrentWeatherResponseimport com.devopworld.weatherapp.feature.mvvm.model.DayWiseTempimport com.devopworld.weatherapp.feature.mvvm.model.ForecastResponseimport com.devopworld.weatherapp.feature.mvvm.model.WeatherInformationimport com.devopworld.weatherapp.network.NoConnectivityExceptionimport com.devopworld.weatherapp.repository.WeatherRepositoryimport dagger.hilt.android.lifecycle.HiltViewModelimport kotlinx.coroutines.*import javax.inject.Injectimport kotlin.math.roundToInt//here  inject our weather repository@HiltViewModelclass WeatherViewModel @Inject constructor(    private val repository: WeatherRepository,    private val context: MyApp) : ViewModel() {    //first it will be idle    private val _weatherData = MutableLiveData<RequestState<WeatherInformation>>(RequestState.Idle)    //set all the data in livedata from mutable state to immutable state    val weatherInfo: LiveData<RequestState<WeatherInformation>> = _weatherData    fun getWeatherInfo() {        _weatherData.value = RequestState.Loading        //check if network is there        if (NetworkUtil.isNetworkAvailable(context)) {            try {                //launch coroutine scope                viewModelScope.launch {                    //call api get the current temperature                    val weatherResponse = async { repository.getWeather() }                    // call second api get all the forecast report                    val forecastResponse = async { repository.getForecast() }                    //wait for them to return successfully                    if (weatherResponse.await()!=null && forecastResponse.await()!=null && weatherResponse.await()!!.isSuccessful && forecastResponse.await()!!.isSuccessful) {                        //if response is successfully then                        //get temperature forecast for the next 4 days (average temperature for each day)                        val futureForecast = async {                            getFourDayAvgTemperature(                                forecastResponse.await()!!.body()!!.forecastList                            )                        }                        if (futureForecast.await().size > 0) {                            _weatherData.value = RequestState.Success(                                WeatherInformation(                                    futureForecast.await(),                                    weatherResponse = weatherResponse.await()!!                                        .body() as CurrentWeatherResponse                                )                            )                        }                    }else{                        _weatherData.value = RequestState.Error(NoConnectivityException())                    }                }            } catch (e: Exception) {                _weatherData.value = RequestState.Error(e)            }        } else { //show error screen            _weatherData.value = RequestState.Error(Exception("No internet Connection"))        }    }    private suspend fun getFourDayAvgTemperature(forecastList: List<ForecastResponse.list>): LinkedHashMap<Int, DayWiseTemp> {        val hashMap = LinkedHashMap<Int, DayWiseTemp>()        val daysInSeconds = 86400        var daysCount = 1;        while (daysCount < 5) {            val nextDayStartingTime =                DateTimeUtility.getCurrentDateStartTimeStamp() + (daysInSeconds * daysCount)            val nextDayEndingTime =                DateTimeUtility.getCurrentDateEndTimeStamp() + (daysInSeconds * daysCount)            var countInterval = 1;            var totalTemp = 0.00            for (item in forecastList) {                if (item.dt in nextDayStartingTime..nextDayEndingTime) {                    totalTemp += TemperatureUtility.convertKelvinToCelsius(item.main.temp)                    countInterval++                }            }            val avg = (totalTemp.roundOff() / countInterval).roundOff()            hashMap[daysCount-1] = DayWiseTemp(DateTimeUtility.convertTimeStampToDay(nextDayStartingTime),avg.roundToInt())            daysCount++;        }        return hashMap    }}